## 1.JZ-替换空格

[题目来源](https://www.nowcoder.com/practice/0e26e5551f2b489b9f58bc83aa4b6c68?tpId=13&tqId=11155&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tab=answerKey)

请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为`We%20Are%20Happy`。

示例：
```
输入：
"We Are Happy"

输出：
"We%20Are%20Happy"
```

解法一：开辟一个新的字符串存储

```cpp
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param s string字符串 
     * @return string字符串
     */
    string replaceSpace(string s) {
        string res;  //存储结果
        for(auto c:s) {
            if(c == ' ') {
                res += "%20";
            }
            else {
                res += c;
            }
        }
        return res;
    }
};
```

解法二：使用`C++ STL`

```cpp
class Solution {
public:
    string replaceSpace(string s) {
        for(int i=0;i<s.size();++i) {
            if(s[i] == ' '){
                //从第i个开始的第1个字符替换成 %20
                s.replace(i,1,"%20");
            }
        }
        return s;
    }
};
```

## 2.JZ-字符串的排序

[题目来源](https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&tqId=11180&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tab=answerKey)


输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符`a,b,c`所能排列出来的所有字符串`abc,acb,bac,bca,cab`和`cba`。

输入描述：输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。

示例：
```
输入：
"ab"

返回值：
["ab","ba"]
```

```cpp
class Solution {
public:
    vector<string> res;
    string path;
    vector<string> Permutation(string str) {
        if(str == "") return res;  //[""] []
        //全排列
        //可能重复字母 靠在一起 好判断
        sort(str.begin(),str.end());
        path.resize(str.size());
        //全排列函数
        dfs(str, 0, 0, 0);
        
        //字典顺序
        sort(res.begin(), res.end());
        return res;
    }
    
    void dfs(string &str, int idx, int start, int state)
    {
        //已经找到一个排列
        if(idx == str.size())
        {
            res.push_back(path);
            return;
        }
        //单个排列没有排完
        //相同字母而言 前后关系  
        //可能重复排序
        //通过控制相对顺序不变确保不重复
        if(idx == 0 || str[idx] != str[idx - 1]) start = 0;
        //顺序往后
        for(int i = start; i < str.size(); i ++)
            if(!(state >> i & 1))
            {
                path[i] = str[idx];
                dfs(str, idx + 1, i + 1, state + (1 << i));
            }
    }
};
```