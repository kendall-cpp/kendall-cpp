## 1.反转链表(重点)
[题目来源](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=190&tqId=35203&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fjob-code-high-rd%2Fquestion-ranking&tab=answerKey)

输入一个链表，反转链表后，输出新链表的表头。

示例：
```
输入：
{1,2,3}
输出：
{3,2,1}
```

题解：使用尾插发

```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        if(!pHead || !pHead->next) return pHead;
        ListNode * p = pHead; //交换指针
        ListNode * q = pHead->next;//遍历指针
        pHead = NULL;
        while(q) {
            p->next = pHead;
            pHead = p;
            p = q;
            q = q->next;
        }
        //插入最后一个元素
        p->next = pHead;
        pHead = p;
        return pHead;
    }
};
```

## 排序
[题目来源](https://www.nowcoder.com/practice/2baf799ea0594abd974d37139de27896?tpId=190&tqId=36114&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fjob-code-high-rd%2Fquestion-ranking&tab=answerKey)

题解一：快速排序


```cpp
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 将给定数组排序
     * @param arr int整型vector 待排序的数组
     * @return int整型vector
     */
    vector<int> MySort(vector<int>& arr) {
        //快速排序
        quick_sort(arr, 0, arr.size()-1);
        return arr;
    }
    void quick_sort(vector<int>& arr,int start,int end) {
        if(start >= end) return;
        int left = start;
        int right = end;
        int temp = arr[right];
        while(left < right) {
            //从左向右
            while(left < right && arr[left] <= temp){
                ++left;
            }
            arr[right] = arr[left];
            //从右往左
            while(left < right && arr[right] >= temp) {
                --right;
            }
            arr[left] = arr[right];
        }
        //遍历一遍完，这时候left=right arr[left]已经确定
        //递归进行第二次变能力
        arr[right] = temp;
        if(left!=start) {
            quick_sort(arr, start,left - 1);
        }
        if(right!=end) {
            quick_sort(arr, left + 1, end);
        }
    }
};
```

效率更高

```cpp
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 将给定数组排序
     * @param arr int整型vector 待排序的数组
     * @return int整型vector
     */
    vector<int> MySort(vector<int>& arr) {
        //快速排序
        quickSort(arr, 0, arr.size()-1);
        return arr;
    }
    void quickSort(vector<int>& arr,int left,int right) {
        if (left >= right) return;
        int a = arr[left], l = left + 1, r = right;
        while (l <= r) {
            if (arr[l] > a) swap(arr[l], arr[r--]);
            else l++;
        }
        swap(arr[r], arr[left]);
        quickSort(arr, left, r - 1);
        quickSort(arr, r+1, right);
    }
};
```
