## 1.JZ50-数组中的重复数字
[题目来源](https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tab=answerKey)

题目描述
在一个长度为n的数组里的所有数字都在`0`到`n-1`的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中第一个重复的数字。 例如，如果输入长度为7的数组`{2,3,1,0,2,5,3}`，那么对应的输出是第一个重复的数字`2`。

返回描述：

如果数组中有重复的数字，函数返回`true`，否则返回`false`。

如果数组中有重复的数字，把重复的数字放到参数`duplication[0]`中。（`ps`:`duplication`已经初始化，可以直接赋值使用。）

**思路**:

> 搞清楚`nums[i]`和`nums[nums[i]]`，循环交换，确保数组下标0的元素是0，下标1的元素是1，找到不相等的就停下来

还可以把当前序列当成是一个下标和下标对应值是相同的数组（时间复杂度为`O(n)`,空间复杂度为`O(1)）`； 遍历数组，判断当前位的值和下标是否相等：

- 若相等，则遍历下一位；
- 若不等，则将当前位置i上的元素和`a[i]`位置上的元素比较：若它们相等，则找到了第一个相同的元素；若不等，则将它们两交换。换完之后`a[i]`位置上的值和它的下标是对应的，但i位置上的元素和下标并不一定对应；重复`2`的操作，直到当前位置i的值也为`i`，将`i`向后移一位，再重复`2`。


举例说明：`{2,3,1,0,2,5,3}`

- `0`(索引值)和`2`(索引值位置的元素)不相等，并且`2`(索引值位置的元素)和`1`(以该索引值位置的元素2为索引值的位置的元素)不相等，则交换位置，数组变为：`{1,3,2,0,2,5,3}`；
- `0`(索引值)和`1`(索引值位置的元素)仍然不相等，并且`1`(索引值位置的元素)和3(以该索引值位置的元素1为索引值的位置的元素)不相等，则交换位置，数组变为：`{3,1,2,0,2,5,3}`；
- `0`(索引值)和`3`(索引值位置的元素)仍然不相等，并且`3`(索引值位置的元素)和0(以该索引值位置的元素3为索引值的位置的元素)不相等，则交换位置，数组变为：`{0,1,2,3,2,5,3}`；
- `0`(索引值)和`0`(索引值位置的元素)相等，遍历下一个元素；
- `1`(索引值)和`1`(索引值位置的元素)相等，遍历下一个元素；
- `2`(索引值)和`2`(索引值位置的元素)相等，遍历下一个元素；
- `3`(索引值)和`3`(索引值位置的元素)相等，遍历下一个元素；
- `4`(索引值)和`2`(索引值位置的元素)不相等，但是2(索引值位置的元素)和2(以该索引值位置的元素2为索引值的位置的元素)相等，则找到了第一个重复的元素。

```cpp
class Solution {
public:
    // Parameters:
    //        numbers:     an array of integers
    //        length:      the length of array numbers
    //        duplication: (Output) the duplicated number in the array number
    // Return value:       true if the input is valid, and there are some duplications in the array number
    //                     otherwise false
    bool duplicate(int numbers[], int length, int* duplication) {
        if(numbers == NULL || length < 2) {
            return false;
        }
        for(int i=0;i<length;++i){
            if(numbers[i] == i){
                continue;
            }
            else if(numbers[i] != numbers[numbers[i]]) {
                swap(numbers[i],numbers[numbers[i]]);
            }
            else {
                *duplication = numbers[i];
                return true;
            }
        }
        return false;
    }
};

```
对应 [leetcode题](https://leetcode-cn.com/problems/find-the-duplicate-number/submissions/)

给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。

假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。

解法一：

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int len = nums.size() - 1;
        sort(nums.begin(),nums.end());
        //排序之后再从两边查找
        int left = 0,right = len;
        while(left < right) {
            if(nums[left] == nums[right]) {
                return nums[left];
            }
            else if(nums[left] == nums[left + 1]) {
                return nums[left];
            }else if(nums[right] == nums[right - 1]) {
                return nums[right];
            }
            ++left;
            --right;
        }
        return 0;
    }
};

```

解法二：

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        if(nums.size() < 2) {
            return -1;
        }
        for(int i = 0; i < nums.size();i++){
            if(nums[i]==i){
                 continue;
            }else if(nums[nums[i]] != nums[i]){
                swap(nums[nums[i]], nums[i]);
                --i;  //索引值不能变
            }else{
                return nums[i];
            }
        }
        return 0;
    }
};
```

## 2.JZ2-二维数组中的查找

[题目来源](https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tab=answerKey)

题目描述

在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

示例
```
输入
7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]

返回值
true
```

思路：找到左下角的位置，行减列增

```cpp
class Solution {
public:
    bool Find(int target, vector<vector<int> > array) {
        int ln = array[0].size()-1; //总共有多少列
        int rn = array.size() - 1;    //总共有多少行
        int line = 0;  //列
        int row = rn;  //行
        while(line <= ln && row >= 0) {
            if(target > array[row][line]){
                ++line;
            }
            else if(target < array[row][line]){
                -- row;
            }
            else{
                return true;
            }
        }
        return false;
    }
};
```

## 3.JZ6-旋转数组的最小数字

[题目来源](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tab=answerKey)

题目描述

把一个数组最开始(有序的)的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

示例
```
输入：
[3,4,5,1,2]
返回值：
1
```
思路：使用二分查找

时间复杂度：二分，所以为`O(logN)`， 但是如果是`[1, 1, 1, 1]`,会退化到`O(n)`

空间复杂度：没有开辟额外空间，为`O(1)`

```cpp
class Solution {
public:
    int minNumberInRotateArray(vector<int> rotateArray) {
        if(rotateArray.size() == 0) {
            return 0;
        }
        int left = 0;
        int right = rotateArray.size() - 1;
        int mid = 0;
        while(left < right) {
            mid = (left + right)/2;
            if(rotateArray[mid] >= rotateArray[right]){
                left = mid + 1;
            }
            else {
                right = mid;
            }
        }
        return rotateArray[right];
    }
};
```

## 4.JZ65-矩阵中的路径

[题目来源](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof)

```
请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。

[["a","b","c","e"],
["s","f","c","s"],
["a","d","e","e"]]

但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。

```
示例：

```
示例 1：

输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

思路：使用`dfs`+回溯，从四个方向查找，`i+1,i-1,j+1,j-1`。在进行`dfs`时，如果数组越界，或者没找到就返回`false`。

```cpp
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        if(word.size() == 0) {
            return false;
        }
        for(int i=0;i<board.size();++i) {
            for(int j=0;j<board[0].size();++j) {
                //使用回溯法解题
                // 0表示字符串的第一个元素
                if(dfs(board,word,i,j,0)) return true;
            }
        }
        return false;
    }
    bool dfs(vector<vector<char>>& board, string & word,int i,int j,int w) {
        //如果数组越界，或者没找到就返回false
        if(i<0 || i>=board.size() || j<0 || j>=board[0].size() || board[i][j] != word[w]) {
            return false;
        }
        //如果已经匹配完了就返回true
        if(w == word.length() -  1) return true;
        
        char temp = board[i][j];
        // 将当前元素标记为'\0'，即一个不可能出现在word里的元素，表明当前元素不可再参与比较
        board[i][j] = '\0'; 
        //上下左右四个方向找
        if(dfs(board,word,i+1,j,w+1)
        || dfs(board,word,i-1,j,w+1)
        || dfs(board,word,i,j-1,w+1)
        || dfs(board,word,i,j+1,w+1))
        {
            // 当前元素的上下左右，如果有匹配到的，返回true
            return true;
        }

        // 将当前元素恢复其本身
        board[i][j] = temp;
        return false;
    }
};
```

[剑指offer上](https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tab=answerKey)的答案

```cpp
class Solution {
public:
    bool hasPath(char* matrix, int rows, int cols, char* str)
    {
        if(rows==1&&cols==1)
            if(matrix[0]==str[0]) return true;
        else
            return false;
     //matrix 一维  str目标字符串
      for(int i=0;i<rows;i++)
      {
          for(int j=0;j<cols;j++)
          {
              if(dfs(matrix,rows,cols,str,i,j,0)) return true;
          }
      }
        return false;
    }
    bool dfs(char* matrix, int rows, int cols, char* str, int x, int y,int u)
    {
        if(str[u]=='\0') return true;
        int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};
        for(int i=0;i<4;i++)
        {
            int a=x+dx[i],b=y+dy[i];
            if(a>=0&&a<rows&&b>=0&&b<cols&&matrix[a*cols+b]==str[u])
            {
                char t=matrix[a*cols+b];
                matrix[a*cols+b]='*';
                if(dfs(matrix,rows,cols,str,a,b,u+1)) return true;
                 matrix[a*cols+b]=t;
            }
        }
        return false;
    }
    
};
```

## 5.JZ66-机器人的运动范围
题目来源:[剑指offer](https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tqId=11219&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tab=answerKey) /
[leetcode](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

地上有一个m行n列的方格，从坐标 `[0,0]` 到坐标 `[m-1,n-1]` 。一个机器人从坐标 `[0, 0]` 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于`k`的格子。 例如，当`k`为`18`时，机器人能够进入方格`（35,37）`，因为`3+5+3+7 = 18`。但是，它不能进入方格`（35,38`），因为`3+5+3+8 = 19`。请问该机器人能够达到多少个格子？

示例：
```
输入：m = 2, n = 3, k = 1
输出：3

输入：m = 3, n = 1, k = 0
输出：1

提示：

1 <= n,m <= 100
0 <= k <= 20
```


