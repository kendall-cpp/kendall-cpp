## 有效的字母异位词
[题目来源](https://leetcode-cn.com/problems/valid-anagram/)

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例：
```
输入: s = "anagram", t = "nagaram"
输出: true

输入: s = "rat", t = "car"
输出: false
```
```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        if(s.length() != t.length()) {
            return false;
        }
        int len = s.length();
        vector<int> count(26,0);
        for(int i=0;i<s;++i) {
            ++count[s[i]-'a'];
            --count[t[i]-'a'];
        }
        for(int i=0;i<26;++i) {
            if(count[i])
                return false;
        }
        return true;
    }
};
```

## 同构字符串
[题目来源](https://leetcode-cn.com/problems/isomorphic-strings/)

给定两个字符串 s 和 t，判断它们是否是同构的。

如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。

所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。

示例：
```
输入: s = "egg", t = "add"
输出: true

输入: s = "foo", t = "bar"
输出: false
```

思路：

记录两个字符串每个位置的字符第一次出现的位置，如果两个字 符串中相同位置的字符与它们第一次出现的位置一样，那么这两个字符串同构。举例来说，对于 “paper”和“title”，假设我们现在遍历到第三个字符“p”和“t”，发现它们第一次出现的位置都在第一个字符，则说明目前位置满足同构。

```cpp
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        vector s_index(256,0),t_index(256,0);
        for(int i=0;i<s.length();++i) {
            if(s_index[s[i]] != t_index[t[i]]) {
                return false;
            }
            s_index[s[i]] = t_index[t[i]] = i+1;
        }

        return true;
    }
};
```

##  回文子串
[题目来源](https://leetcode-cn.com/problems/palindromic-substrings/)

给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 

示例 1：
```
输入："abc"
输出：3
解释：三个回文子串: "a", "b", "c"
```
```cpp
class Solution {
public:
    int countSubstrings(string s) {
        int n = s.size(), ans = 0;
        for (int i = 0; i < n; ++i) {
            int l = i, r = i; //以单字母为中心
            while (l >= 0 && r < n && s[l--] == s[r++]) ++ans;
            l = i, r = i + 1; //以双字母为中心
            while (l >= 0 && r < n && s[l--] == s[r++]) ++ans;
        }
        return ans;
    }
};
```
