## 常见的排序算法
### 快速排序
```cpp
#include <iostream>
#include <vector>
using namespace std;

void quick_sort(vector<int> &nums, int l, int r) 
{
    if (l + 1 >= r) 
	{
		return;
	}
    int first = l, last = r - 1, key = nums[first];
    while (first < last){
		while(first < last && nums[last] >= key) {
			--last;
		}
		nums[first] = nums[last];
		while (first < last && nums[first] <= key) {
			++first;
		}
		nums[last] = nums[first];
    }
    nums[first] = key;
    quick_sort(nums, l, first);
    quick_sort(nums, first + 1, r);
}
```
### 归并排序
```cpp
void merge_sort(vector<int> &nums, int l, int r, vector<int> &temp) 
{
    if (l + 1 >= r) 
	{
		return; 
	}
	// divide
    int m = l + (r - l) / 2;
    merge_sort(nums, l, m, temp);
	merge_sort(nums, m, r, temp);
	// conquer
    int p = l, q = m, i = l;
    while (p < m || q < r) {
       if (q >= r || (p < m && nums[p] <= nums[q])) {
           temp[i++] = nums[p++];
       } else {
           temp[i++] = nums[q++];
		} 
	}
	for (i = l; i < r; ++i) {
		nums[i] = temp[i];
	} 
}
```

### 插入排序

```cpp
void insertion_sort(vector<int> &nums, int n) {
    for (int i = 0; i < n; ++i) {
        for (int j = i; j > 0 && nums[j] < nums[j-1]; --j) {
           swap(nums[j], nums[j-1]);
		} 
	}
}
```

### 冒泡排序

```cpp
void bubble_sort(vector<int> &nums, int n) {
    bool swapped;
    for (int i = 1; i < n; ++i) {
		swapped = false;
		for (int j = 1; j < n - i + 1; ++j) {
			if (nums[j] < nums[j-1]) {
				swap(nums[j], nums[j-1]);
				swapped = true;
			} 
		}
		if (!swapped) {
			break;
		} 
	}
}
```

### 选择排序

```cpp
void selection_sort(vector<int> &nums, int n) {
    int mid;
    for (int i = 0; i < n - 1; ++i) {
    	mid = i;
		for (int j = i + 1; j < n; ++j) {
			if (nums[j] < nums[mid]) {
				mid = j; 
			}
		}
    	swap(nums[mid], nums[i]);
    }
}
```

测试：

```cpp
int main() 
{
	vector<int> nums = {1,3,5,7,2,6,4,8,9,2,8,7,6,0,3,5,9,4,1,0};
	vector<int> temp(nums.size());

	//调用自己实现的排序函数
	quick_sort(nums,0,nums.size());
	merge_sort(nums,0,nums.size(),temp);
	insertion_sort(nums, nums.size());
	bubble_sort(nums, nums.size());
    selection_sort(nums, nums.size());
	for(int i=0;i<nums.size();++i)
	{
		cout << nums[i] << ' ';
	}
	cout << endl;
    return  0;

}
```

## 1.剑指offer-最小的k个数

[题目来源](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

示例：

```
输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]
```

题解：      
先排序后取出前k个数

```cpp
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        if(arr.size() == 0 || arr.size() <= k) 
        {
            return arr;
        }
        vector<int> res;
        sort(arr.begin(),arr.end());
        for(int i=0;i<k;++i) {
            res.push_back(arr[i]);
        }
        return res;
    }
};
```

## 2.215数组中的第K个最大元素

[题目来源](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

示例：

```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

题解：

方法一：排序后取出第K大个元素（面试时建议提一下就好）

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        
        sort(nums.begin(),nums.end(),[](int x,int y){
            return x > y;
        });
        return nums[k-1];
    }
};
```

方法二：

小顶堆实现实现：

```cpp
// Min heap, O(NlgK)
class Solution3 {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int, vector<int>, greater<int>> pq;
        for (int i = 0; i < nums.size(); i++) {
            pq.push(nums[i]);
            if (pq.size() > k) {
                pq.pop();
            }
        }

        return pq.top();
    }
};
```

方法三：大顶堆实现

```cpp
class Solution2 {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int> pq;
        for (int i = 0; i < nums.size(); i++) {
            pq.push(nums[i]);
        }

        for (int i = 0; i < k - 1; i++) {
            pq.pop();
        }

        return pq.top();
    }
};
```

方法三：大顶堆

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int> pq;
        for(int i=0;i<nums.size();++i)
        {
            pq.push(nums[i]);
        }
        //从大顶堆中删除k-1个元素
        for(int i=0;i<k-1;++i){
            pq.pop();
        }
        return pq.top();
    }
};
```

## 3.347前 K 个高频元素

[题目来源](https://leetcode-cn.com/problems/top-k-frequent-elements/)

给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

示例
```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]

输入: nums = [1], k = 1
输出: [1]
```

题解：桶排序

顾名思义，桶排序的意思是为每个值设立一个桶，桶内记录这个值出现的次数(或其它属
性)，然后对桶进行排序。针对样例来说，我们先通过桶排序得到三个桶 [1,2,3,4]，它们的值分别 为 [4,2,1,1]，表示每个数字出现的次数。      
紧接着，我们对桶的频次进行排序，前 k 大个桶即是前 k 个频繁的数。这里我们可以使用各种 排序算法，甚至可以再进行一次桶排序，把每个旧桶根据频次放在不同的新桶内。针对样例来说， 因为目前最大的频次是 4，我们建立 [1,2,3,4] 四个新桶，它们分别放入的旧桶为 [[3,4],[2],[],[1]]， 表示不同数字出现的频率。最后，我们从后往前遍历，直到找到 k 个旧桶。

```cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> num_freq;//以每个数字为key，存该数字出现的次数
        int max_freq = 0;
        for(int num : nums){
            num_freq[num] ++;
            if(num_freq[num] > max_freq)
                max_freq = num_freq[num];
        }
        vector<stack<int>> bucket(max_freq+1, stack<int>());//桶的下标是频次，内容是同频次的数字。下标为0的桶为空。
        for(auto& it : num_freq){
            bucket[it.second].push(it.first);
        }
        vector<int> topK;//存答案
        int freq = max_freq;
        while(freq > 0 && topK.size() < k){//控制topK中只存k个
            while(!bucket[freq].empty() && topK.size() < k){//控制topK中只存k个
                topK.push_back(bucket[freq].top());
                bucket[freq].pop();
            }
            freq--;
        }
        return topK;
    }
};

```

## 4. 451根据字符出现频率排序
[题目来源](https://leetcode-cn.com/problems/sort-characters-by-frequency/)

解题思路
- 1.申请一个辅助队列来记录字符出现的频率
- 2.申请一个数组模拟哈希记录每个字符出现的次数
- 3.队列元素依次出列，去模拟哈希数组里面找到出现对于次数的字符
- 4.追加字符到str
- 5.结束当前循环，当前字符位置设置为0。


```cpp
class Solution {
public:
    string frequencySort(string s) {

        string str;
        vector<int>hash(128,0);
        int j;
        priority_queue<int,vector<int>,less<int>>que;
        for(int i=0;i<s.size();i++)
        {
            hash[s[i]]++;
        }
        for(int i=0;i<hash.size();i++)
        {
            if(hash[i])
            {
                que.push(hash[i]);
            }
        }
        while(!que.empty())
        {
            int res=que.top();
            for( j=0;j<hash.size();j++)
            {
                if(hash[j]==res)
                {
                   for(int k=0;k<res;k++)
                   {
                       str+=(char)j;
                   }
                   break;
                }
            }
            hash[j]=0;
            que.pop();
        }
        return str;
    }
};
```
