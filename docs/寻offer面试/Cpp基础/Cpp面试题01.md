## 1.有没有了解过(复制)拷贝构造函数
1.1 拷贝构造函数是一种特殊的构造函数，函数名称必须和类的名称一致，它只有一个参数，参数类型是本类的引用。

1.2 它的作用是用来赋值复制对象，使用这个对象的实例来初始化这个对象的另一个实例

1.3 复制构造函数被调用的三种情况：
- 当一个对象去初始化同类的另一个对象时，复制构造函数会被调用
```cpp
Complex c2(c1);
Complex c2 = c1;
```
- 函数的返回值是类A的对象时，则类A的赋值构造函数会被调用
- 对象需要通过另外一个对象进行初始化时，赋值构造函数会被调用
```cpp
#include<iostream>
using namespace std;
class A{
public:
    A(){};
    A(A & a){
        cout<<"Copy constructor called"<<endl;
    }
};
void Func(A a){ }
int main(){
    A a;
    Func(a);
    return 0;
}
```
程序的输出结果为：      
`Copy constructor called`           
这是因为 Func 函数的形参 a 在初始化时调用了复制构造函数。

1.4 此外，拷贝构造函数默认为**浅拷贝**，浅拷贝是指当前类进行等号赋值时，它能够完成静态成员的值复制。当数据成员中没有指针时，浅拷贝是可行的。但当数据成员中有指针时，如果采用简单的浅拷贝，则两个类中的指针将指向同一个地址，对象即将结束时，两个类会分别调用析构函数，导致指针悬挂现象。所以这时必须采用深拷贝，在堆内存中另外申请空间来储存数据，防止指针悬挂现象。
> 深拷贝与浅拷贝可以参考我的[另一篇文章](/C++随记/C++深拷贝和浅拷贝.md)

1.5 还有就是，拷贝构造函数必须是引用传递，不能是值传递，这是为了防止递归引用。

## 2.说一下C++里的智能指针

2.1 C++里面的四个智能指针，`auto_ptr`，`unique_ptr`，`shared_ptr`，`weak_ptr`，其中后三个是c++11支持，并且第一个已经被c++11弃用。

2.2 使用原因：智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针是一个类，当超出了类的实例对象的作用域时，会自动调用对象的析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

- `auto_ptr`：采用所有权模式。p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以`auto_ptr`的缺点是：存在潜在的内存崩溃问题。

- `unique_ptr`：实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用，可以通过标准库的move()函数实现指针转移。

- `shared_ptr`：实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。

- `weak_ptr`：是一种不控制对象生命周期的智能指针, weak_ptr 设计的目的是为配合 `shared_ptr` 而引入的一种智能指针来协助 `shared_ptr` 工作, 它只可以从一个 `shared_ptr` 或另一个 `weak_ptr` 对象构造, 它的构造和析构不会引起引用记数的增加或减少。



