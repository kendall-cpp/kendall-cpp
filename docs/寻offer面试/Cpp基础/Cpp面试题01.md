## 1.有没有了解过(复制)拷贝构造函数

1.1 拷贝构造函数是一种特殊的构造函数，函数名称必须和类的名称一致，它只有一个参数，参数类型是本类的引用。

1.2 它的作用是用来复制对象，使用这个对象的实例来初始化这个对象的另一个实例

1.3 复制构造函数被调用的三种情况：
- 当用一个对象去初始化同类的另一个对象时，复制构造函数会被调用
```cpp
Complex c2(c1);
Complex c2 = c1;
```
- 函数的返回值是类A的对象时，则类A的复制构造函数会被调用
- 当函数的参数为类的对象时，复制构造函数会被调用
```cpp
#include<iostream>
using namespace std;
class A{
public:
    A(){};
    A(A & a){
        cout<<"Copy constructor called"<<endl;
    }
};
//函数的参数为类A的对象a
void Func(A a){ }
int main(){
    A a;
    Func(a);
    return 0;
}
```
程序的输出结果为：      
`Copy constructor called`           
这是因为 Func 函数的形参 a 在初始化时调用了复制构造函数。

1.4 此外，拷贝构造函数默认为**浅拷贝**，浅拷贝是指当前类进行等号赋值时，它能够完成静态成员的值复制。当数据成员中没有指针时，浅拷贝是可行的。但是当数据成员中有指针时，如果采用简单的浅拷贝，那么这两个类中的指针将指向同一个地址，对象即将结束时，两个类会分别调用析构函数，导致指针悬挂现象。所以这时必须采用深拷贝，在堆内存中另外申请空间来储存数据，防止指针悬挂现象。

> 这时候大概率会问深拷贝和浅拷贝。深拷贝与浅拷贝可以参考我的[另一篇文章](/C++随记/C++深拷贝和浅拷贝.md)

1.5 还有就是，拷贝构造函数必须是引用传递，不能是值传递，这是为了防止递归引用。

## 2.说一下深拷贝和浅拷贝

- 浅拷贝将源对象的值拷贝到目标对象中去，也就是说源对象和目标对象使用的还是同一个实体，只是他们的变量名不同，但是它们的地址是相同的。
- 深拷贝在拷贝时先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标拷贝对象中去，这样两个指针就指向了不同的内存位置，并且里面的内容还是一样的。在拷贝构造函数中深拷贝可以解决指针悬挂问题。

## 3.说一下C++里的智能指针

 C++里面的四个智能指针，`auto_ptr`，`unique_ptr`，`shared_ptr`，`weak_ptr`，其中后三个是c++11支持，并且第一个已经被c++11弃用。

 使用原因：智能指针的作用是管理一个指针，因为在程序设计中动态分配的堆内存没有正确释放或无法释放，导致资源浪费，程序运行速度变慢等问题。使用智能指针可以很大程度上的避免这个问题，因为智能指针是一个类，当超出了类的实例对象的作用域时，会自动调用对象的析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

- `auto_ptr`：采用所有权模式。`p2`剥夺了`p1`的所有权，但是当程序运行时访问`p1`将会报错。所以`auto_ptr`的缺点是：存在潜在的内存崩溃问题。

- `unique_ptr`：实现独占式模式，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以`new`创建对象后因为发生异常而忘记调用`delete`”)特别有用，可以通过标准库的`move()`函数实现指针转移。

- `shared_ptr`：实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字`share`就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。

- `weak_ptr`：是一种不控制对象生命周期的智能指针, `weak_ptr` 设计的目的是为配合 `shared_ptr` 而引入的一种智能指针来协助 `shared_ptr` 工作, 它只可以从一个 `shared_ptr` 或另一个 `weak_ptr` 对象构造, 它的构造和析构不会引起引用记数的增加或减少。

更详细的C++智能指针分析见《[C++智能指针](/C++随记/07C++智能指针)》

## 3.C++中如何实现HashMap？用什么冲突处理方法？时间复杂度？

如何避免哈希碰撞：

（1）开放地址法：开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入

（2）再哈希法：当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不在产生为止

（3）链地址法：将哈希表的每个单元作为链表的头结点，所有哈希地址为 `i` 的元素构成一个同义词链表。即发生冲突时就把该关键字加在以该单元为头节点的链表的尾部

（4）建立公共溢出区：将哈希表分为基本表和溢出表两部分，发生冲突的元素都放在溢出表中

不管插入还是查找，由`key`获取`hash`值然后定位到桶的时间复杂度都是 `O(1)` ，那么真正决定时间复杂度的实际上是桶里面链表/红黑树的情况。如果桶里面没有元素，那么直接将元素插入或者直接返回未查找到，时间复杂度就是 `O(1)`，如果里面有元素，那么就沿着链表进行遍历，时间复杂度就是 `O(n)`，链表越短时间复杂度越低，如果是红黑树的话那就是 `O(lgn)`。

因此`HashMap`的查找时间复杂度只有在最理想的情况下才会为 `O(1)`。

## 4.malloc 和 new 的区别

- (1)`malloc `和 `new` 都是堆上开辟内存的		
 * `malloc`只负责开辟内存，没有初始化功能， 需要用户自己初始化；
 * `new`不但开辟内存，还可以进行初始化，如`new int[10];`表示堆上开辟了一个4字节的`int`整形内存，初始值为10，再比如`new int[10] ()`；表示在堆上开辟了一个包含10个整形元素的数组，初始值都为0。

- (2)`malloc`是函数，开辟内存需要传入字节数，如`malloc(100)`；表示在堆上开辟了100个字节的内存，返回`void*`，表示分配的堆内存的起始地址，因此`malloc`的返回值需要强转成指定类型的地址；`new`是运算符，开辟内存需要指定类型，返回指定类型的地址，因此不需要进行强转。

```cpp
int *p1 = (int*)malloc(sizeof(int));   
=>  根据传入字节数开辟内存，没有初始化

int *p2 = new int(0); 
=>  根据指定类型int开辟一个整形内存，初始化为0

int *p3 = (int*)malloc(sizeof(int)*100);  
=>  开辟400个字节的内存，相当于包含100个整形元素的数组，没有初始化

int *p4 = new int[100]();  
=>  开辟400个字节的内存，100个元素的整形数组，元素都初始化为0  
```

- (3）`malloc`开辟内存失败返回`NULL`，`new`开辟内存失败抛出`bad_alloc`类型的异常，需要捕获异常才能判断内存开辟成功或失败，`new`运算符其实是`operator new`函数的调用，它底层调用的也是`malloc`来开辟内存的，`new`它比`malloc`多的就是初始化功能，对于类类型来说，所谓初始化，就是调用相应的构造函数。

- (4）`malloc`开辟的内存永远是通过`free`来释放的；而`new`单个元素内存，用的是`delete`，如果`new[]`数组，用的是`delete[]`来释放内存的。

- (5）`malloc`开辟内存只有一种方式，而`new`有四种分别是普通的`new`（内存开辟失败抛出`bad_alloc`异常）, `nothrow`版本的`new`，`const new`以及定位`new`。

## 5.说一下vector

### 5.1 vector底层原理

- `vector `底层是一个动态数组，包含三个迭代器，`start`和 `finish`之间是已经被使用的空间范围，`end_of_storage`是整块连续空间包括备用空间的尾部。
- 空间不够装下数据（`vec.push_back(val)`）时，会自动申请灵一片更大的空间（1.5倍或者2倍），然后把原来的数据拷贝到新的内存空间，接着释放原来的那篇空间（vactor内存增长机制）。
- 当释放或者删除（`vec.clear()`）容器里面的数据时，它的存储空间不释放，仅仅是清空了里面的数据，因此，`vector`的任何操作一旦引起了空间的重新配置，指向原来的`vector`的所有迭代器都会失效了。

### 5.2 `vector` 的 `push_back` 时间复杂度是多少？

简单来说就是，均摊（Amortized）时间复杂度为`O(1)`。

因为 `vector` 的 `push_back` 是在每次达到 `capacity` 才会申请新内存，然后复制过去，也就是进行 `m * n` 次操作，但是每 `n` 次操作才会进行这样的复制，所以相当于 `n` 次操作进行 `(m + 1) * n `次操作，每次就是均摊 (m + 10)，也就是常数时间 `O(1)`。		
 [参考](https://blog.csdn.net/bob__yuan/article/details/102632924)

### 5.3 vector迭代器失效的情况

- 当插入一个元素到`vector`中，由于引起了内存重新分配，所以指向原内存的迭代器全部失效。
- 当删除容器中一个元素后,该迭代器所指向的元素已经被删除，那么也造成迭代器失效。erase方法会返回下一个有效的迭代器，所以当我们要删除某个元素时，需要`it=vec.erase(it);`。

## 6.说一下指针和引用的区别

* 指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量的本身进行操作
* 指针可以有多级，引用只有一级
* 传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改
* 指针的大小一般是4个字节，引用的大小取决于被引用对象的大小
* 指针可以为空，引用不可以。

### 6.2 什么时候使用指针，什么时候使用引用？在函数参数传递的时候
* 需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的
* 对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小
* 类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式

## 7.堆和栈的区别是什么

* 从定义上：堆是由new和malloc开辟的一块内存，由程序员手动管理，栈是编译器自动管理的内存，存放函数的参数和局部变量。
* 堆空间因为会有频繁的分配释放操作，会产生内存碎片
* 堆的生长空间向上，地址越来越大，栈的生长空间向下，地址越来越小

### 7.1 堆快一点还是栈快一点？

栈快一点。因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。而堆的操作是由`C/C++`函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。

## 8.C++异常机制

简述一下“栈展开”的过程?

A:栈展开的就是指匹配catch子句的过程。

具体匹配过程如下：

- 1）当程序抛出一个异常或者在try块中检测到异常时就会停止执行当前的调用链，开始寻找与异常匹配的catch子句。
- 2）当在try块中出现一个throw语句或者在try块中调用了可能出现异常的函数时，首先检查与该try块匹配的catch语句（一个try可能对应多个catch），逐个检查，直到找到匹配的即停止寻找，进入该catch执行处理异常的程序。（注意，匹配不代表最佳匹配，所以最佳的匹配要放在catch的最前端）。
- 3）如果执行过程2）还是没有找到匹配的catch，且当前try嵌套在外部的try块中，则程序就会在外部的try块中查找，直到找到匹配的为止。
- 4）如果执行过程3）还是没有找到匹配的catch语句，则退出当前调用的函数，继续在退出为止的函数的其他函数中寻找，以此类推。
- 5）如果最终执行完上述步骤后还是没有找到匹配的catch，则就是说异常得不到处理（没有被捕获），程序会电泳标准库函数terminate终止函数的执行。

> 另外见《逆袭进大厂 49》