## 1.字节后端开发日常实习

### 1.1 malloc 和 new 的区别

- (1)`malloc `和 `new` 都是堆上开辟内存的		
 * `malloc`只负责开辟内存，没有初始化功能， 需要用户自己初始化；
 * `new`不但开辟内存，还可以进行初始化，如`new int[10];`表示堆上开辟了一个4字节的`int`整形内存，初始值为10，再比如`new int[10] ()`；表示在堆上开辟了一个包含10个整形元素的数组，初始值都为0。

- (2)`malloc`是函数，开辟内存需要传入字节数，如`malloc(100)`；表示在堆上开辟了100个字节的内存，返回`void*`，表示分配的堆内存的起始地址，因此`malloc`的返回值需要强转成指定类型的地址；`new`是运算符，开辟内存需要指定类型，返回指定类型的地址，因此不需要进行强转。

```cpp
int *p1 = (int*)malloc(sizeof(int));   
=>  根据传入字节数开辟内存，没有初始化

int *p2 = new int(0); 
=>  根据指定类型int开辟一个整形内存，初始化为0

int *p3 = (int*)malloc(sizeof(int)*100);  
=>  开辟400个字节的内存，相当于包含100个整形元素的数组，没有初始化

int *p4 = new int[100]();  
=>  开辟400个字节的内存，100个元素的整形数组，元素都初始化为0  
```

- (3）`malloc`开辟内存失败返回`NULL`，`new`开辟内存失败抛出`bad_alloc`类型的异常，需要捕获异常才能判断内存开辟成功或失败，`new`运算符其实是`operator new`函数的调用，它底层调用的也是`malloc`来开辟内存的，`new`它比`malloc`多的就是初始化功能，对于类类型来说，所谓初始化，就是调用相应的构造函数。

(4）`malloc`开辟的内存永远是通过`free`来释放的；而`new`单个元素内存，用的是`delete`，如果`new[]`数组，用的是`delete[]`来释放内存的。


(5）`malloc`开辟内存只有一种方式，而`new`有四种分别是普通的`new`（内存开辟失败抛出`bad_alloc`异常）, `nothrow`版本的`new`，`const new`以及定位`new`。

### 1.2 vector的底层原理
- `vector `底层是一个动态数组，包含三个迭代器，`start`和 `finish`之间是已经被使用的空间范围，`end_of_storage`是整块连续空间包括备用空间的尾部。
- 空间不够装下数据（`vec.push_back(val)`）时，会自动申请灵一片更大的空间（1.5倍或者2倍），然后把原来的数据拷贝到新的内存空间，接着释放原来的那篇空间（vactor内存增长机制）。
- 当释放或者删除（`vec.clear()`）容器里面的数据时，它的存储空间不释放，仅仅是清空了里面的数据，因此，`vector`的任何操作一旦引起了空间的重新配置，指向原来的`vector`的所有迭代器都会失效了。

### 1.3 `vector` 的 `push_back` 时间复杂度是多少？

简单来说就是，均摊（Amortized）时间复杂度为`O(1)`。

因为 `vector` 的 `push_back` 是在每次达到 `capacity` 才会申请新内存，然后复制过去，也就是进行 `m * n` 次操作，但是每 `n` 次操作才会进行这样的复制，所以相当于 `n` 次操作进行 `(m + 1) * n `次操作，每次就是均摊 (m + 10)，也就是常数时间 `O(1)`。		
 [参考](https://blog.csdn.net/bob__yuan/article/details/102632924)

### 1.4 vector迭代器失效的情况

- 当插入一个元素到`vector`中，由于引起了内存重新分配，所以指向原内存的迭代器全部失效。
- 当删除容器中一个元素后,该迭代器所指向的元素已经被删除，那么也造成迭代器失效。erase方法会返回下一个有效的迭代器，所以当我们要删除某个元素时，需要`it=vec.erase(it);`。


### 1.5 `i++`在两个线程执行100次，最终的结果是

> [参考](https://blog.csdn.net/m0_37962600/article/details/78239256)

## 2.CVTE C++ 一面


