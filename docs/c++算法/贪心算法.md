## 分发饼干
[题目来源](https://leetcode-cn.com/problems/assign-cookies/)

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

示例:
```
输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
```

```js
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(),g.end());
        sort(s.begin(),s.end());
        int gid = 0,sid = 0;
        while(gid < g.size() && sid < s.size()) {
            if(g[gid] <= s[sid]) ++gid;
            ++sid;
        }
        return gid ;
    }
};
```

## 分发糖果
[题目来源](https://leetcode-cn.com/problems/candy/)

老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

你需要按照以下要求，帮助老师给这些孩子分发糖果：

每个孩子至少分配到 1 个糖果。
相邻的孩子中，评分高的孩子必须获得更多的糖果。
那么这样下来，老师至少需要准备多少颗糖果呢？

示例1：
```
输入: [1,0,2]
输出: 5
解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。
```
做完了题目 455，你会不会认为存在比较关系的贪心策略一定需要排序或是选择?虽然这一 道题也是运用贪心策略，但我们只需要简单的两次遍历即可:把所有孩子的糖果数初始化为 1; 先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的 糖果数加 1;再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数 不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加 1。通过这两次遍历， 分配的糖果就可以满足题目要求了。这里的贪心策略即为，在每次遍历中，只考虑并更新相邻一 侧的大小关系。
在样例中，我们初始化糖果分配为 [1,1,1]，第一次遍历更新后的结果为 [1,1,2]，第二次遍历 更新后的结果为 [2,1,2]。

```js
class Solution {
public:
    int candy(vector<int>& ratings) {
        int len = ratings.size();
        
        if(len < 2) return len;

        vector<int> suger(len,1);
        int i = 0;
        while(i < len - 1) {
            if(ratings[i] < ratings[i+1]) {
                suger[i+1] = suger[i] + 1;
            }
            ++i;
        }
        i = len -1;
        while(i > 0 ) {
            if(ratings[i - 1] > ratings[i]) {
                suger[i - 1] = max(suger[i-1],suger[i] + 1);
            }
            --i;
        }
        return accumulate(suger.begin(),suger.end(),0); //求和
    }
};
```

## 无重叠区间

[题目来源](https://leetcode-cn.com/problems/non-overlapping-intervals/)

给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

注意:

可以认为区间的终点总是大于它的起点。
区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。
示例 1:
```
输入: [ [1,2], [2,3], [3,4], [1,3] ]

输出: 1

解释: 移除 [1,3] 后，剩下的区间没有重叠。
```

在选择要保留区间时，区间的结尾十分重要:选择的区间结尾越小，余留给其它区间的空间 就越大，就越能保留更多的区间。因此，我们采取的贪心策略为，优先保留结尾小且不相交的区 间。

具体实现方法为，先把区间按照结尾的大小进行增序排序，每次选择结尾最小且和前一个选 择的区间不重叠的区间。我们这里使用 C++ 的 Lambda，结合 std::sort() 函数进行自定义排 序。

在样例中，排序后的数组为 [[1,2], [1,3], [2,4]]。按照我们的贪心策略，首先初始化为区间 [1,2];由于 [1,3] 与 [1,2] 相交，我们跳过该区间;由于 [2,4] 与 [1,2] 不相交，我们将其保留。因 此最终保留的区间为 [[1,2], [2,4]]。

> 注意 需要根据实际情况判断按区间开头排序还是按区间结尾排序。

```js
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if(intervals.empty()) {
            return 0;
        }
        int n = intervals.size();
        
        //排序
        sort(intervals.begin(), intervals.end(), [](vector<int> a, vector<int> b) {
            return a[1] < b[1];
        });
        //从最左边的区间的右边开始
        int total = 0,prev = intervals[0][1];
        for(int i=1;i<n;++i) {
            //每个区间的左边和prev比较，prev大，则total自增1
            if(intervals[i][0]< prev) {
                ++ total;
            }else {
                //当删除了一个区间，即这个区间对该题就无影响了，因此prev要取尽小值
                prev = intervals[i][1];
            }
        }
        return total;
    }
};
```