## 第七章
C++ 中保留了C语言的 struct 关键字，并且加以扩充。在C语言中，struct 只能包含成员变量，不能包含成员函数。     
而在C++中，struct 类似于 class，既可以包含成员变量，又可以包含成员函数。 
       
C++中的 `struct` 和 `class` 基本是通用的，唯有几个细节不同：
- 1:使用 `class` 时，类中的成员默认都是 private 属性的；而使用 `struct` 时，结构体中的成员默认都是 `public` 属性的。(最本质的区别)
- 2:`class` 继承默认是 `private` 继承，而 struct 继承默认是 `public` 继承（《C++继承与派生》一章会讲解继承）。
- 3:`class` 可以使用模板，而 `struct` 不能。
  
### 类
简单来说就是数据和它的操作的一种封装，内部提供接口函数

定义在类内部的函数是隐式的inline函数。
```js
class A {
public:
    void Fun(int x,int y);
};
//定义文件
inline void A::Fun(int x, int y) {};
```
关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。      
所以说，inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”

```js
// 如下风格的函数Foo 不能成为内联函数：
inline void Foo(int x, int y); // inline 仅与函数声明放在一起
void Foo(int x, int y){}

// 而如下风格的函数Foo 则成为内联函数：
void Foo(int x, int y);
inline void Foo(int x, int y){} // inline 与函数定义体放在一起
```

以下情况不宜使用内联：
- （1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。
- （2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构函数可能会隐藏一些行为，如“偷偷地”执行了基类或成员对象的构造函数和析构函数。所以不要随便地将构造函数和析构函数的定义体放在类声明中。一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了 inline 不应该出现在函数的声明中）。

### 关于this
this隐式形参是一个本身是常量的指针，它指向调用该函数的对象。        
this形参隐式定义，任何自定义名为this的参数或变量都是非法的。
```
//this的类型：Sales_data * const
total.isbn(); // this=&total;
```

**关于函数参数列表后面的const**

- 在const成员函数中，this是一个本身和其所指都是常量的指针。
- 常量对象，及对常量对象的引用和指针只能调用const成员函数 ；普通对象可以调用普通成员函数和const成员函数。
- 对于const成员函数，其this指向常量，可以被常量对象和非常量对象调用，函数灵活性更好；对于普通成员函数，其this指向非常量，只能被非常量对象调用。
```js
// f：成员函数
// 第1个const：返回值是常量
// 第2个const：形参是常量
// 第3个const：函数是常量成员函数
const int A::f(const int ci) const 
{
    return ci;
}
```

定义一个返回this对象的函数
`return *this`

